[{"/Users/dohyeon.kim/Desktop/workspace/web-api/src/index.tsx":"1","/Users/dohyeon.kim/Desktop/workspace/web-api/src/pages/App.tsx":"2","/Users/dohyeon.kim/Desktop/workspace/web-api/src/constants/route.ts":"3","/Users/dohyeon.kim/Desktop/workspace/web-api/src/pages/Home.tsx":"4","/Users/dohyeon.kim/Desktop/workspace/web-api/src/components/layout/Navigate.tsx":"5","/Users/dohyeon.kim/Desktop/workspace/web-api/src/pages/Broadcast/detail.tsx":"6","/Users/dohyeon.kim/Desktop/workspace/web-api/src/pages/Broadcast/index.tsx":"7","/Users/dohyeon.kim/Desktop/workspace/web-api/src/pages/MediaStream/Devices.tsx":"8","/Users/dohyeon.kim/Desktop/workspace/web-api/src/pages/BackgroundTask.tsx":"9","/Users/dohyeon.kim/Desktop/workspace/web-api/src/pages/MediaStream/Track.tsx":"10","/Users/dohyeon.kim/Desktop/workspace/web-api/src/pages/MediaStream/index.tsx":"11","/Users/dohyeon.kim/Desktop/workspace/web-api/src/pages/ResizeObserver.tsx":"12","/Users/dohyeon.kim/Desktop/workspace/web-api/src/pages/Notification.tsx":"13","/Users/dohyeon.kim/Desktop/workspace/web-api/src/pages/WebGL.tsx":"14","/Users/dohyeon.kim/Desktop/workspace/web-api/src/pages/WebRTC/Local.tsx":"15","/Users/dohyeon.kim/Desktop/workspace/web-api/src/pages/WebRTC.tsx":"16","/Users/dohyeon.kim/Desktop/workspace/web-api/src/pages/Performance/index.tsx":"17","/Users/dohyeon.kim/Desktop/workspace/web-api/src/pages/Performance/Observer.tsx":"18","/Users/dohyeon.kim/Desktop/workspace/web-api/src/pages/WebRTC/Remote/index.tsx":"19","/Users/dohyeon.kim/Desktop/workspace/web-api/src/pages/WebRTC/Remote/Detail.tsx":"20","/Users/dohyeon.kim/Desktop/workspace/web-api/src/components/styles/common.ts":"21","/Users/dohyeon.kim/Desktop/workspace/web-api/src/components/styles/text.ts":"22","/Users/dohyeon.kim/Desktop/workspace/web-api/src/components/styles/input.ts":"23","/Users/dohyeon.kim/Desktop/workspace/web-api/src/lib/webgl.ts":"24","/Users/dohyeon.kim/Desktop/workspace/web-api/src/components/Toggle.tsx":"25","/Users/dohyeon.kim/Desktop/workspace/web-api/src/components/AsyncToggle.tsx":"26","/Users/dohyeon.kim/Desktop/workspace/web-api/src/components/PerformanceTestButton.tsx":"27","/Users/dohyeon.kim/Desktop/workspace/web-api/src/utils/index.ts":"28","/Users/dohyeon.kim/Desktop/workspace/web-api/src/lib/ResizeObservable.ts":"29"},{"size":255,"mtime":1676787624233,"results":"30","hashOfConfig":"31"},{"size":2310,"mtime":1676787624242,"results":"32","hashOfConfig":"31"},{"size":1156,"mtime":1676787624233,"results":"33","hashOfConfig":"31"},{"size":255,"mtime":1676787624247,"results":"34","hashOfConfig":"31"},{"size":1289,"mtime":1676787624231,"results":"35","hashOfConfig":"31"},{"size":2628,"mtime":1676787624243,"results":"36","hashOfConfig":"31"},{"size":1168,"mtime":1676787624243,"results":"37","hashOfConfig":"31"},{"size":3582,"mtime":1676787624248,"results":"38","hashOfConfig":"31"},{"size":9225,"mtime":1676787624242,"results":"39","hashOfConfig":"31"},{"size":5326,"mtime":1676787624248,"results":"40","hashOfConfig":"31"},{"size":2967,"mtime":1676787624248,"results":"41","hashOfConfig":"31"},{"size":4097,"mtime":1676787624256,"results":"42","hashOfConfig":"31"},{"size":5322,"mtime":1676787624249,"results":"43","hashOfConfig":"31"},{"size":2803,"mtime":1676787624256,"results":"44","hashOfConfig":"31"},{"size":8224,"mtime":1676787624257,"results":"45","hashOfConfig":"31"},{"size":8098,"mtime":1676787624257,"results":"46","hashOfConfig":"31"},{"size":3468,"mtime":1676787624251,"results":"47","hashOfConfig":"31"},{"size":4508,"mtime":1676787624251,"results":"48","hashOfConfig":"31"},{"size":3228,"mtime":1676787624258,"results":"49","hashOfConfig":"31"},{"size":8749,"mtime":1676787624258,"results":"50","hashOfConfig":"31"},{"size":1479,"mtime":1676787624232,"results":"51","hashOfConfig":"31"},{"size":972,"mtime":1676787624233,"results":"52","hashOfConfig":"31"},{"size":375,"mtime":1676787624232,"results":"53","hashOfConfig":"31"},{"size":793,"mtime":1676787624241,"results":"54","hashOfConfig":"31"},{"size":5763,"mtime":1676787624231,"results":"55","hashOfConfig":"31"},{"size":5430,"mtime":1676787624230,"results":"56","hashOfConfig":"31"},{"size":2273,"mtime":1676787624230,"results":"57","hashOfConfig":"31"},{"size":1051,"mtime":1676787624259,"results":"58","hashOfConfig":"31"},{"size":2246,"mtime":1676787624241,"results":"59","hashOfConfig":"31"},{"filePath":"60","messages":"61","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"bga2bu",{"filePath":"62","messages":"63","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"64","messages":"65","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"66","messages":"67","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"68","messages":"69","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"70","messages":"71","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"72","messages":"73","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"74","messages":"75","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"76"},{"filePath":"77","messages":"78","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"79","messages":"80","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"81","messages":"82","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"83","messages":"84","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"85"},{"filePath":"86","messages":"87","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"88","messages":"89","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"90","messages":"91","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"92"},{"filePath":"93","messages":"94","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"95"},{"filePath":"96","messages":"97","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"98","messages":"99","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"100","messages":"101","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"102"},{"filePath":"103","messages":"104","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"105","messages":"106","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"107","messages":"108","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"109","messages":"110","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"111","messages":"112","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"113","messages":"114","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"115"},{"filePath":"116","messages":"117","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"118"},{"filePath":"119","messages":"120","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"121","messages":"122","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"123","messages":"124","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"/Users/dohyeon.kim/Desktop/workspace/web-api/src/index.tsx",[],"/Users/dohyeon.kim/Desktop/workspace/web-api/src/pages/App.tsx",[],"/Users/dohyeon.kim/Desktop/workspace/web-api/src/constants/route.ts",[],"/Users/dohyeon.kim/Desktop/workspace/web-api/src/pages/Home.tsx",[],"/Users/dohyeon.kim/Desktop/workspace/web-api/src/components/layout/Navigate.tsx",[],"/Users/dohyeon.kim/Desktop/workspace/web-api/src/pages/Broadcast/detail.tsx",[],"/Users/dohyeon.kim/Desktop/workspace/web-api/src/pages/Broadcast/index.tsx",[],"/Users/dohyeon.kim/Desktop/workspace/web-api/src/pages/MediaStream/Devices.tsx",["125","126"],"import React from 'react';\nimport { Button, Header, Section, Ul } from '@src/components/styles/common';\nimport { Code, H1, H2, P } from '@src/components/styles/text';\nimport Toggle from '@src/components/Toggle';\n\ninterface EnumerateDevices {\n  deviceId: string;\n  groupId: string;\n  kind: string;\n  label: string;\n}\n\nconst MediaDevices: React.FC = () => {\n  const [enumerateDevices, setEnumerateDevices] = React.useState<EnumerateDevices[]>([]);\n  const videoRef = React.useRef<HTMLVideoElement>(null);\n\n  React.useEffect(() => {\n    navigator.mediaDevices.enumerateDevices()\n      .then(devices => {\n        setEnumerateDevices(devices);\n      })\n  }, []);\n\n  const constraints: MediaStreamConstraints = {\n    audio: true,\n    video: true\n    // video: {\n    //   width: { max: 1920, ideal: 1600},\n    // }\n  }\n\n  const runUserMedia = React.useCallback(() => {\n    navigator.mediaDevices.getUserMedia(constraints)\n      .then(mediaStream => {\n        if(videoRef.current) {\n          videoRef.current.srcObject = mediaStream;\n        }\n      })\n  }, [videoRef, constraints]);\n\n  const runDisplayMedia = React.useCallback(() => {\n    // @ts-ignore\n    navigator.mediaDevices.getDisplayMedia(constraints)\n    .then((mediaStream: MediaStream) => {\n      if(videoRef.current) {\n        videoRef.current.srcObject = mediaStream;\n      }\n    })\n  }, [videoRef]);\n\n  return (\n    <>\n      <Header>\n        <H1>MediaDevices</H1>\n        <P>MediaDevices 는 화면 또는 기기에 연결 된 미디어 입력 장치에 대한 엑세스를 제공한다. 본질적으로는 미디어 데이터의 모든 하드웨어 소스에 엑세스 할 수 있다.</P>\n        <P>MediaDevices의 API는 아래와 같이 제공된다.</P>\n      </Header>\n      <Section>\n        <H2>event</H2>\n        <Ul>\n          <li>devicechange</li>\n        </Ul>\n      </Section>\n      <Section>\n        <H1>method</H1>\n        <Ul>\n          <li>enumerateDevices : 미디어 입력 및 출력 장치 목록을 반환한다. 반환 값은 <Code>{'Promise<MediaDeviceInfo>'}</Code> 이다.</li>\n          <li>getSupportedConstraints : 사용자 기기의 <Code>MediaTrackSupportedConstraints</Code>를 반환한다.</li>\n          <li>getDisplayMedia : 사용자 화면의 스트림 데이터를 반환한다. 반환 값은 <Code>{'Promise<MediaStream>'}</Code>이다</li>\n          <li>getUserMedia : 사용자 기기와 연결 된 미디어 입력 장치의 스트림 데이터를 반환한다. 반환 값은 <Code>{'Promise<MediaStream>'}</Code>이다</li>\n        </Ul>\n      </Section>\n      <Section>\n        <Toggle title={<P>enumerate devices</P>}>\n          <Ul>\n            {enumerateDevices.map(({groupId, kind, label}) => (\n              <li key={groupId}>\n                kind : {kind} / label : {label}\n              </li>\n            ))}\n          </Ul>\n        </Toggle>\n        <Toggle title={<P>supported constraints</P>}>\n          <Ul>\n            {Object.entries(navigator.mediaDevices.getSupportedConstraints()).map(([key, value]) => (\n              <li key={`${key}-${value}`}>\n                {key} : {value.toString()}\n              </li>\n            ))}\n          </Ul>\n        </Toggle>\n        <Section>\n          <P>\n            <Button onClick={runUserMedia}>getUserMedia</Button>\n          </P>\n          <P>\n            <Button onClick={runDisplayMedia}>getDisplayMedia</Button>\n          </P>\n        </Section>\n        <Section>\n          <video ref={videoRef} autoPlay style={{maxWidth: '1000px'}} />\n        </Section>\n      </Section>\n    </>\n  )\n}\n\nexport default MediaDevices;","/Users/dohyeon.kim/Desktop/workspace/web-api/src/pages/BackgroundTask.tsx",[],"/Users/dohyeon.kim/Desktop/workspace/web-api/src/pages/MediaStream/Track.tsx",[],"/Users/dohyeon.kim/Desktop/workspace/web-api/src/pages/MediaStream/index.tsx",[],"/Users/dohyeon.kim/Desktop/workspace/web-api/src/pages/ResizeObserver.tsx",["127"],"import React from 'react';\nimport styled from '@emotion/styled';\nimport { Header, Section } from '@src/components/styles/common';\nimport { H1, H2, P, Code, Em } from '@src/components/styles/text';\nimport Toggle from '@src/components/Toggle';\nimport Async from '@src/components/AsyncToggle';\n\nconst MY_TEXT = '낮엔 파란하늘\\n 별이 보이는밤 \\n 기분좋은날 모두 모일까 내가사랑하는 삶을 사랑하지 나는\\n 우야야야야\\n'\nlet IMAGES = [\n  ...(process.env.REACT_APP_DUMP_IMAGES ?? '').split(','),\n];\n\nfor(let i = 0; i < 20; i ++) {\n  IMAGES.push(`https://picsum.photos/600/600/?random${Math.random() * i}`);\n}\n\nconst ResizeObserverPage: React.FC = () => {\n  const [text, setText] = React.useState<string>('');\n  const addTextHandler = React.useCallback(() => {\n    setText(prev => !!prev ? '' : MY_TEXT);\n  }, [setText]);\n\n  const getContents = React.useCallback((open) => {\n    const content = (\n      <GridLayout>\n        {IMAGES.map((url) => (\n          <div key={`async-${url}`}>\n            <img src={url} alt=\"image\"/>\n          </div>\n        ))}\n    </GridLayout>\n    )\n    if(open) {\n      return new Promise(resolve => {\n        setTimeout(() => {\n          resolve(content);\n        }, 500)\n      })\n    }\n  }, []);\n\n  return (\n    <>\n      <Header>\n        <H1>ResizeObserver</H1>\n        <P>\n          ResizeObserver는 엘리먼트의 사이즈가 변경 됬을 때를 감지하여 관찰자에게 알림과 함께 요소의 크기 변경을 모니터링 할 수 있게 해주는 API이다.\n        </P>\n      </Header>\n      <Section>\n        <H2>Why?</H2>\n        <P>\n          기존에서는 엘리먼트 사이즈 변경 시 처리를 하고 싶다면, <Code>Element</Code> 이벤트 중 <Code>onresize</Code>이벤트를 등록하고, 해당 엘리먼트에 접근하여<br/>\n          <Code>clientHeight</Code>, <Code>getBoundingClientRect()</Code> 등 엘리먼트에 직접 접근하거나 <Code>Window.getComputedStyle()</Code>에 접근하여 크기값을 가져와야했다.<br/>\n          하지만 이러한 솔루션은 제한 된 사용 사례에서만 사용하고 성능에도 좋지 않으며 (프로퍼티를 접근하거나 메서드를 실행하는것 만으로 reflow가 발생함) , 브라우저 창 크기가 변경되지 않으면 작동하지 않는 경우가 많았다.          \n        </P>\n        <P>\n          Resize Observer API는 이러한 문제에 대한 솔루션을 제공하고 요소의 박스 모델 크기 변경을 성능적으로 제공한다.\n        </P>\n        <ExampleSection>\n          <Toggle title={<P>예제(텍스트)</P>}>\n            <P>해당 컴포넌트는 Resize Observer API를 통해 엘리먼트의 사이즈를 구하고<br/> style 속성 중 height 속성을 스위칭 시키는 형태의 컴포넌트이다.</P>\n            <div>\n              {!!text && text.split('\\n').map(text => (\n                  <P key={text}>\n                    {text}\n                  </P>\n              ))}\n              <P onClick={addTextHandler}><Em>텍스트 추가</Em></P>\n            </div>\n          </Toggle>\n        </ExampleSection>\n        <ExampleSection>\n          <Toggle title={<P>예제(이미지)</P>} duration={700}>\n            <GridLayout>\n              {IMAGES.map(url => (\n                <div key={url}>\n                  <img src={url} alt=\"banner\" />\n                </div>\n              ))}\n            </GridLayout>\n          </Toggle>\n        </ExampleSection>\n        <ExampleSection>\n          <Async title={<P>예제(비동기)</P>} loading={<P>Loading...</P>}>\n            {getContents}\n          </Async>\n        </ExampleSection>\n      </Section>\n    </>\n  )\n};\n\nconst GridLayout = styled.div`\n  display: grid;\n  grid-template-columns: repeat(3, 1fr);\n  column-gap: 10px;\n  row-gap: 15px;\n  align-items: center;\n`;\n\nconst ExampleSection = styled.div`  \n  width: 100%;\n  .toggle__content {\n    border: 1px solid #ddd;\n\n    &.hidden {\n      border-color: transparent;\n    }\n  }\n`;\n\nResizeObserverPage.displayName = 'ResizeObserverPage';\nexport default ResizeObserverPage;","/Users/dohyeon.kim/Desktop/workspace/web-api/src/pages/Notification.tsx",[],"/Users/dohyeon.kim/Desktop/workspace/web-api/src/pages/WebGL.tsx",[],"/Users/dohyeon.kim/Desktop/workspace/web-api/src/pages/WebRTC/Local.tsx",["128"],"import React, { MutableRefObject } from 'react';\nimport styled from '@emotion/styled';\nimport { Article, Button, Header, Section } from '@src/components/styles/common';\nimport { H1, H2, P } from '@src/components/styles/text';\n\nconst WebRTCLocal: React.FC = () => {\n  const localDisabledTracks = React.useRef<MediaStreamTrack[]>([]);\n  const localVideoRef = React.useRef<HTMLVideoElement>(null);\n  const remoteVideoRef = React.useRef<HTMLVideoElement>(null);\n  const userMediaStreamRef: MutableRefObject<null | MediaStream> = React.useRef(null);\n  \n  const [isPlay, setIsPlay] = React.useState<boolean>(false);\n  const [isVideo, setIsVideo] = React.useState<boolean>(true);\n  const [isAudio, setIsAudio] = React.useState<boolean>(true);\n  const [localPeerConnection, setLocalPeerConnection] = React.useState<RTCPeerConnection | null>(null);\n  const [remotePeerConnection, setRemotePeerConnection] = React.useState<RTCPeerConnection| null>(null);\n  \n  const requestGetUserMedia = React.useCallback(() => {\n    const constraints = {\n      video: isVideo,\n      audio: isAudio\n    };\n    navigator.mediaDevices.getUserMedia(constraints)\n      .then(mediaStream => {\n        userMediaStreamRef.current = mediaStream;\n        localVideoRef.current!.srcObject = mediaStream;\n      });\n  }, [localVideoRef, isVideo, isAudio, userMediaStreamRef]);\n\n  const closeUserMedia = React.useCallback(() => {\n    if(remoteVideoRef.current) {\n      remoteVideoRef.current.srcObject = null;\n    }\n    (userMediaStreamRef.current?.getTracks?.() ?? [])\n      .forEach(track => track.stop());\n    \n    setLocalPeerConnection(peerConnection => {\n      peerConnection?.close();\n      return null\n    });\n    setRemotePeerConnection(peerConnection => {\n      peerConnection?.close();\n      return null;\n    })\n  }, [userMediaStreamRef, remoteVideoRef, setLocalPeerConnection, setRemotePeerConnection])\n\n  const handleConnection = React.useCallback((event) => {\n    const peerConnection = event.target;\n    const iceCandidate = event.candidate;\n\n    if(iceCandidate) {\n      const newIceCandidate = new RTCIceCandidate(iceCandidate);\n      const otherPeer = peerConnection === localPeerConnection\n        ? remotePeerConnection \n        : localPeerConnection;\n      otherPeer!.addIceCandidate(newIceCandidate)\n    }\n  }, [localPeerConnection, remotePeerConnection]);\n\n  const onLoadLocalVideoMedaDataHandler = React.useCallback((event) => {\n    const {current: localVideo} = localVideoRef;\n    \n    if(localVideo && localPeerConnection && remotePeerConnection) {\n      const {target: {srcObject}} = event;\n      const tracks = (srcObject as MediaStream).getTracks();\n      \n      tracks.forEach(track => localPeerConnection.addTrack(track));\n      localPeerConnection.createOffer({offerToReceiveVideo: true})\n        .then(description => {\n          localPeerConnection.setLocalDescription(description);\n          remotePeerConnection.setRemoteDescription(description);\n\n          remotePeerConnection.createAnswer()\n            .then(description => {\n              remotePeerConnection.setLocalDescription(description);\n              localPeerConnection.setRemoteDescription(description);\n            })\n      });\n    }\n  }, [localVideoRef, localPeerConnection, remotePeerConnection]);\n\n  const togglePlay = React.useCallback(() => {\n    setIsPlay(curr => !curr);\n  }, [setIsPlay]);\n\n  const toggleTracks = React.useCallback((kind: 'video' | 'audio'): MediaStream => {\n    const {current: userMediaStream} = userMediaStreamRef;\n    const method = kind === 'video' ? 'getVideoTracks' : 'getAudioTracks';\n    const targetTracks = userMediaStream![method]() ?? [];\n    \n    if(targetTracks.length) {\n      const newDisabledTracks = targetTracks.map((track) => {\n        userMediaStream?.removeTrack(track);\n        return track;\n      });\n\n      localDisabledTracks.current = [\n        ...localDisabledTracks.current,\n        ...newDisabledTracks\n      ]\n    } else {\n      const disabledTracks = localDisabledTracks.current.filter((track, idx) => {\n        if(track.kind === kind) {\n          localDisabledTracks.current.splice(idx, 1);\n          return true;\n        }\n      })\n      disabledTracks.forEach((track) => {\n        userMediaStream!.addTrack(track);\n      });\n    }\n    return userMediaStream as MediaStream;\n  }, [userMediaStreamRef, localDisabledTracks]);\n\n  const toggleVideo = React.useCallback(() => {\n    setIsVideo(curr => !curr);\n  }, [setIsVideo]);\n  const toggleAudio = React.useCallback(() => {\n    setIsAudio(curr => !curr);\n  }, [setIsAudio]);\n\n  React.useEffect(() => {\n    if(isPlay) {\n      requestGetUserMedia(); \n      setLocalPeerConnection(new RTCPeerConnection())\n      setRemotePeerConnection(new RTCPeerConnection());\n    } else {\n      closeUserMedia();\n    }\n  }, [isPlay, closeUserMedia, requestGetUserMedia]);\n\n  React.useEffect(() => {\n    if(userMediaStreamRef.current) {\n      const mediaStream = toggleTracks('audio');\n      userMediaStreamRef.current = mediaStream;\n      // localVideoRef.current!.srcObject = mediaStream;\n    }\n  }, [isAudio, toggleTracks, userMediaStreamRef]);\n  React.useEffect(() => {\n    if(userMediaStreamRef.current) {\n      const mediaStream = toggleTracks('video');\n      userMediaStreamRef.current = mediaStream;\n    }\n  }, [isVideo, toggleTracks, userMediaStreamRef]);\n\n\n  React.useEffect(() => {\n    const {current} = localVideoRef;\n    if(current) {\n      current.addEventListener('loadedmetadata', onLoadLocalVideoMedaDataHandler);\n    }\n    return () => {\n      if(current) {\n        current.removeEventListener('loadedmetadata', onLoadLocalVideoMedaDataHandler);\n      }\n    }\n  }, [localVideoRef, onLoadLocalVideoMedaDataHandler]);\n  \n  React.useEffect(() => {\n    localPeerConnection?.addEventListener?.('icecandidate', handleConnection);\n    remotePeerConnection?.addEventListener?.('icecandidate', handleConnection);\n\n    return () => {\n      localPeerConnection?.removeEventListener?.('icecandidate', handleConnection);\n      remotePeerConnection?.removeEventListener?.('icecandidate', handleConnection);\n    }\n  }, [localPeerConnection, remotePeerConnection, handleConnection]);\n\n  React.useEffect(() => {\n    const addTrackHandler = (event: MediaStreamTrackEvent) => {\n      if(remoteVideoRef.current) {\n        const mediaStream = remoteVideoRef.current.srcObject \n          ? new MediaStream(remoteVideoRef.current.srcObject as MediaStream)\n          : new MediaStream();\n          \n        mediaStream.addTrack(event.track);\n        remoteVideoRef.current.srcObject = mediaStream;\n      }\n    }\n    \n    remotePeerConnection?.addEventListener('track', addTrackHandler);\n    return () => remotePeerConnection?.removeEventListener('track', addTrackHandler);\n  }, [remotePeerConnection, remoteVideoRef]);\n\n  React.useEffect(() => {\n    return () => {\n      closeUserMedia();\n    }\n  }, [closeUserMedia])\n  \n  return (\n    <>\n      <Header>\n        <H1>WebRTC</H1>\n        <P>\n            WebRTC는 웹 어플리케이션 간의 비디오나 오디오 미디어를 P2P 방식으로 데이터를 교환 하는 기술이다. <br/>\n            Media Stream 또는 Media Capture과 함께 비디오및 오디오, 파일 교환, 화면 공유등 다양한 인터페이스를 포함 한 멀티미디어 기능을 제공한다.<br/>            \n        </P>\n      </Header>\n      <FlexSection>\n        <Article>\n          <H2>Local Video</H2>\n          <div>\n            <video ref={localVideoRef} autoPlay/> <br/>\n            <Button onClick={togglePlay}>{isPlay ? '중지' : '촬영'}</Button>\n            <Button onClick={toggleAudio} disabled={!isVideo || isPlay}>오디오 {isAudio ? 'off' : 'on'}</Button>\n            <Button onClick={toggleVideo} disabled={!isAudio || isPlay}>비디오 {isVideo ? 'off' : 'on'}</Button>\n          </div>\n        </Article>\n        <Article>\n          <H2>Remote Video</H2>\n          <div>\n            <video ref={remoteVideoRef} autoPlay />\n          </div>\n        </Article>\n      </FlexSection>\n    </>\n  )\n};\n\nexport const FlexSection = styled(Section)`\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n\n  article {\n    flex: 1;\n  }\n`;\n\nWebRTCLocal.displayName = 'WebRTCLocal';\nexport default WebRTCLocal;","/Users/dohyeon.kim/Desktop/workspace/web-api/src/pages/WebRTC.tsx",["129"],"import React, { MutableRefObject } from 'react';\nimport styled from '@emotion/styled';\nimport { Article, Button, Header, Section } from '@src/components/styles/common';\nimport { H1, H2, P } from '@src/components/styles/text';\n\nconst WebRTC: React.FC = () => {\n  const localDisabledTracks = React.useRef<MediaStreamTrack[]>([]);\n  const localVideoRef = React.useRef<HTMLVideoElement>(null);\n  const remoteVideoRef = React.useRef<HTMLVideoElement>(null);\n  const userMediaStreamRef: MutableRefObject<null | MediaStream> = React.useRef(null);\n  \n  const [isPlay, setIsPlay] = React.useState<boolean>(false);\n  const [isVideo, setIsVideo] = React.useState<boolean>(true);\n  const [isAudio, setIsAudio] = React.useState<boolean>(true);\n  const [localPeerConnection, setLocalPeerConnection] = React.useState<RTCPeerConnection | null>(null);\n  const [remotePeerConnection, setRemotePeerConnection] = React.useState<RTCPeerConnection| null>(null);\n  \n  const requestGetUserMedia = React.useCallback(() => {\n    const constraints = {\n      video: isVideo,\n      audio: isAudio\n    };\n    navigator.mediaDevices.getUserMedia(constraints)\n      .then(mediaStream => {\n        userMediaStreamRef.current = mediaStream;\n        localVideoRef.current!.srcObject = mediaStream;\n      });\n  }, [localVideoRef, isVideo, isAudio, userMediaStreamRef]);\n\n  const closeUserMedia = React.useCallback(() => {\n    if(remoteVideoRef.current) {\n      remoteVideoRef.current.srcObject = null;\n    }\n    (userMediaStreamRef.current?.getTracks?.() ?? [])\n      .forEach(track => track.stop());\n    \n    setLocalPeerConnection(peerConnection => {\n      peerConnection?.close();\n      return null\n    });\n    setRemotePeerConnection(peerConnection => {\n      peerConnection?.close();\n      return null;\n    })\n  }, [userMediaStreamRef, remoteVideoRef, setLocalPeerConnection, setRemotePeerConnection])\n\n  const handleConnection = React.useCallback((event) => {\n    const peerConnection = event.target;\n    const iceCandidate = event.candidate;\n\n    if(iceCandidate) {\n      const newIceCandidate = new RTCIceCandidate(iceCandidate);\n      const otherPeer = peerConnection === localPeerConnection\n        ? remotePeerConnection \n        : localPeerConnection;\n      otherPeer!.addIceCandidate(newIceCandidate)\n    }\n  }, [localPeerConnection, remotePeerConnection]);\n\n  const onLoadLocalVideoMedaDataHandler = React.useCallback((event) => {\n    const {current: localVideo} = localVideoRef;\n    \n    if(localVideo && localPeerConnection && remotePeerConnection) {\n      const {target: {srcObject}} = event;\n      const tracks = (srcObject as MediaStream).getTracks();\n      \n      tracks.forEach(track => localPeerConnection.addTrack(track));\n      localPeerConnection.createOffer({offerToReceiveVideo: true})\n        .then(description => {\n          localPeerConnection.setLocalDescription(description);\n          remotePeerConnection.setRemoteDescription(description);\n\n          remotePeerConnection.createAnswer()\n            .then(description => {\n              remotePeerConnection.setLocalDescription(description);\n              localPeerConnection.setRemoteDescription(description);\n            })\n      });\n    }\n  }, [localVideoRef, localPeerConnection, remotePeerConnection]);\n\n  const togglePlay = React.useCallback(() => {\n    setIsPlay(curr => !curr);\n  }, [setIsPlay]);\n\n  const toggleTracks = React.useCallback((kind: 'video' | 'audio'): MediaStream => {\n    const {current: userMediaStream} = userMediaStreamRef;\n    const method = kind === 'video' ? 'getVideoTracks' : 'getAudioTracks';\n    const targetTracks = userMediaStream![method]() ?? [];\n    \n    if(targetTracks.length) {\n      const newDisabledTracks = targetTracks.map((track) => {\n        userMediaStream?.removeTrack(track);\n        return track;\n      });\n\n      localDisabledTracks.current = [\n        ...localDisabledTracks.current,\n        ...newDisabledTracks\n      ]\n    } else {\n      const disabledTracks = localDisabledTracks.current.filter((track, idx) => {\n        if(track.kind === kind) {\n          localDisabledTracks.current.splice(idx, 1);\n          return true;\n        }\n      })\n      disabledTracks.forEach((track) => {\n        userMediaStream!.addTrack(track);\n      });\n    }\n    return userMediaStream as MediaStream;\n  }, [userMediaStreamRef, localDisabledTracks]);\n\n  const toggleVideo = React.useCallback(() => {\n    setIsVideo(curr => !curr);\n  }, [setIsVideo]);\n  const toggleAudio = React.useCallback(() => {\n    setIsAudio(curr => !curr);\n  }, [setIsAudio]);\n\n  React.useEffect(() => {\n    if(isPlay) {\n      requestGetUserMedia(); \n      setLocalPeerConnection(new RTCPeerConnection())\n      setRemotePeerConnection(new RTCPeerConnection());\n    } else {\n      closeUserMedia();\n    }\n  }, [isPlay, closeUserMedia, requestGetUserMedia]);\n\n  React.useEffect(() => {\n    if(userMediaStreamRef.current) {\n      const mediaStream = toggleTracks('audio');\n      userMediaStreamRef.current = mediaStream;\n      // localVideoRef.current!.srcObject = mediaStream;\n    }\n  }, [isAudio, toggleTracks, userMediaStreamRef]);\n  React.useEffect(() => {\n    if(userMediaStreamRef.current) {\n      const mediaStream = toggleTracks('video');\n      userMediaStreamRef.current = mediaStream;\n    }\n  }, [isVideo, toggleTracks, userMediaStreamRef]);\n\n\n  React.useEffect(() => {\n    const {current} = localVideoRef;\n    if(current) {\n      current.addEventListener('loadedmetadata', onLoadLocalVideoMedaDataHandler);\n    }\n    return () => {\n      if(current) {\n        current.removeEventListener('loadedmetadata', onLoadLocalVideoMedaDataHandler);\n      }\n    }\n  }, [localVideoRef, onLoadLocalVideoMedaDataHandler]);\n  \n  React.useEffect(() => {\n    localPeerConnection?.addEventListener?.('icecandidate', handleConnection);\n    remotePeerConnection?.addEventListener?.('icecandidate', handleConnection);\n\n    return () => {\n      localPeerConnection?.removeEventListener?.('icecandidate', handleConnection);\n      remotePeerConnection?.removeEventListener?.('icecandidate', handleConnection);\n    }\n  }, [localPeerConnection, remotePeerConnection, handleConnection]);\n\n  React.useEffect(() => {\n    const addTrackHandler = (event: MediaStreamTrackEvent) => {\n      if(remoteVideoRef.current) {\n        const mediaStream = remoteVideoRef.current.srcObject \n          ? new MediaStream(remoteVideoRef.current.srcObject as MediaStream)\n          : new MediaStream();\n          \n        mediaStream.addTrack(event.track);\n        remoteVideoRef.current.srcObject = mediaStream;\n      }\n    }\n    \n    remotePeerConnection?.addEventListener('track', addTrackHandler);\n    return () => remotePeerConnection?.removeEventListener('track', addTrackHandler);\n  }, [remotePeerConnection, remoteVideoRef]);\n  \n  return (\n    <>\n      <Header>\n        <H1>WebRTC</H1>\n        <P>\n            WebRTC는 웹 어플리케이션 간의 비디오나 오디오 미디어를 P2P 방식으로 데이터를 교환 하는 기술이다. <br/>\n            Media Stream 또는 Media Capture과 함께 비디오및 오디오, 파일 교환, 화면 공유등 다양한 인터페이스를 포함 한 멀티미디어 기능을 제공한다.<br/>            \n        </P>\n      </Header>\n      <FlexSection>\n        <Article>\n          <H2>Local Video</H2>\n          <div>\n            <video ref={localVideoRef} autoPlay/> <br/>\n            <Button onClick={togglePlay}>{isPlay ? '중지' : '촬영'}</Button>\n            <Button onClick={toggleAudio} disabled={!isVideo || isPlay}>오디오 {isAudio ? 'off' : 'on'}</Button>\n            <Button onClick={toggleVideo} disabled={!isAudio || isPlay}>비디오 {isVideo ? 'off' : 'on'}</Button>\n          </div>\n        </Article>\n        <Article>\n          <H2>Remote Video</H2>\n          <div>\n            <video ref={remoteVideoRef} autoPlay />\n          </div>\n        </Article>\n      </FlexSection>\n    </>\n  )\n};\n\nconst FlexSection = styled(Section)`\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n\n  article {\n    flex: 1;\n  }\n`;\n\nWebRTC.displayName = 'WebRTC';\nexport default WebRTC;","/Users/dohyeon.kim/Desktop/workspace/web-api/src/pages/Performance/index.tsx",[],"/Users/dohyeon.kim/Desktop/workspace/web-api/src/pages/Performance/Observer.tsx",[],"/Users/dohyeon.kim/Desktop/workspace/web-api/src/pages/WebRTC/Remote/index.tsx",["130"],"import React from 'react';\nimport styled from '@emotion/styled';\nimport { io } from \"socket.io-client\";\nimport { Link, useHistory, useLocation } from 'react-router-dom';\nimport { Button, Header, Section, Ul } from '@src/components/styles/common';\nimport { H1, P } from '@src/components/styles/text';\nimport { Input } from '@src/components/styles/input';\n\nconst socket = io();\n\ntype Room = {\n  title: string;\n  count: number;\n}\n\ntype RoomCountFromSocket = {[key: string]: number};\n\nconst WebRTCRemote = () => {\n  const history = useHistory();\n  const { pathname } = useLocation();\n  const [inputValue, setInputValue] = React.useState<string>('');\n  const [roomList, setRoomList] = React.useState<Room[]>([]);\n  const [loading, setLoading] = React.useState<boolean>(false);\n\n  const inputChangeHandler = React.useCallback(({target: {value}}) => {\n    setInputValue(value);\n  }, [setInputValue]);\n\n  const buttonClickHandler = React.useCallback(() => {\n    socket.emit('createRoom', inputValue);\n    history.push(`${pathname}/${inputValue}`);\n  }, [inputValue, pathname, history]);\n\n  const getRoomListFromSocket = React.useCallback((rooms: RoomCountFromSocket): Room[] => {\n    return Object.entries(rooms).map(([key, value]) => ({\n      title: key,\n      count: value\n    }))\n  }, []);\n\n  React.useEffect(() => {\n    setLoading(true);\n    socket.emit('getRoomList');\n\n    socket.on('roomList', (rooms: RoomCountFromSocket) => {\n      setRoomList(getRoomListFromSocket(rooms));\n      setLoading(false);\n    });\n\n    socket.on('createdRoom', (roomName: string) => {\n      setRoomList(prev => ([\n        ...prev,\n        {title: roomName, count: 0}\n      ]))\n    });\n\n    socket.on('updatedRoom', (rooms: RoomCountFromSocket) => {\n      const roomList = getRoomListFromSocket(rooms);\n      \n      setRoomList(prev => {\n        return prev.map((room) => {\n          const updateRoom = roomList.find(({title}) => title === room.title);\n          if(updateRoom) {\n            return updateRoom;\n          }\n          return room;\n        });\n      })\n    });\n\n    socket.on('deletedRoom', (roomName: string) => {\n      console.log(roomName);\n      setRoomList(prev => prev.filter(({title}) => title !== roomName));\n    })\n  }, [setRoomList, setLoading]);\n\n  return (\n    <>\n      <Header>\n        <H1>Room List</H1>\n      </Header>\n      <Section>\n        {(!roomList.length && !loading) \n          ? <P>방이 없습니다.</P> \n          : loading\n            ? 'loading...'\n            : (\n              <Ul>\n                {roomList.map(({title, count}) => (\n                  <li key={title}>\n                    {count < 2 ? (\n                      <Link to={`${pathname}/${title}`}>{title} ({count}/2)</Link>\n                    ) : (\n                      <DisabledP>{title} ({count}/2)</DisabledP>\n                    )}\n                  </li>\n                ))}\n              </Ul>\n            )\n        }\n      </Section>\n      <Section>\n        <Input type={inputValue} onChange={inputChangeHandler}/>\n        <Button onClick={buttonClickHandler}>방 추가</Button>\n      </Section>\n    </>\n  )\n};\n\nconst DisabledP = styled.p`\n  opacity: 0.5;\n`;\n\nWebRTCRemote.displayName = 'WebRTCRemote';\nexport default WebRTCRemote;\n","/Users/dohyeon.kim/Desktop/workspace/web-api/src/pages/WebRTC/Remote/Detail.tsx",[],"/Users/dohyeon.kim/Desktop/workspace/web-api/src/components/styles/common.ts",[],"/Users/dohyeon.kim/Desktop/workspace/web-api/src/components/styles/text.ts",[],"/Users/dohyeon.kim/Desktop/workspace/web-api/src/components/styles/input.ts",[],"/Users/dohyeon.kim/Desktop/workspace/web-api/src/lib/webgl.ts",[],"/Users/dohyeon.kim/Desktop/workspace/web-api/src/components/Toggle.tsx",["131","132","133"],"import React from 'react';\nimport styled from '@emotion/styled';\nimport ResizeObservable from '@src/lib/ResizeObservable';\nimport { isExistWithInTimeout } from '@src/utils';\n\nexport interface ToggleProps {\n  title: React.ReactNode;\n  children: React.ReactNode;\n  duration?: number;\n  loading?: React.ReactNode;\n  timeout?: number;\n}\n\nconst ob = new ResizeObservable();\n\nconst Toggle: React.FC<ToggleProps> = ({\n  title, \n  children, \n  loading,\n  duration = 300, \n  timeout = 3000\n}) => {\n  const contentRef = React.useRef<HTMLDivElement>(null);\n  const lastHeightRef = React.useRef<number>(0);\n  const [heightValue, setHeightValue] = React.useState<string>('0px');\n  const [isInit, setIsInit] = React.useState<boolean>(false); // 실 컨텐츠 높이가 구해졌는가?\n  const [isOpen, setIsOpen] = React.useState<boolean>(false);\n  const [isAnimating, setIsAnimating] = React.useState<boolean>(false);\n  const [isLoading, setIsLoading] = React.useState<boolean>(false);\n\n  const resizeHandler = React.useCallback(({height}: DOMRect) => {\n    if(isOpen && height && !isAnimating) {\n      lastHeightRef.current = height;\n    }\n  }, [isAnimating, isOpen, lastHeightRef]);\n\n  React.useLayoutEffect(() => {\n    ob.register(contentRef.current as HTMLDivElement, resizeHandler);\n    return () => ob.disconnect();\n  }, [resizeHandler, contentRef]);\n\n  React.useLayoutEffect(() => {\n    const transitionStartHandler = () => setIsAnimating(true);\n    const transitionEndHandler = () => setIsAnimating(false);\n    \n    contentRef.current?.addEventListener('transitionstart', transitionStartHandler);\n    contentRef.current?.addEventListener('transitionend', transitionEndHandler);\n    contentRef.current?.addEventListener('transitioncancel', transitionEndHandler);\n\n    return () => {\n      contentRef.current?.removeEventListener('transitionstart', transitionStartHandler);\n      contentRef.current?.removeEventListener('transitionend', transitionEndHandler);\n      contentRef.current?.removeEventListener('transitioncancel', transitionEndHandler);\n    }\n  }, [contentRef, setHeightValue, setIsAnimating]);\n\n  const onLoadContentHandler = React.useCallback<() => Promise<number>>(() => {\n    return new Promise(async (resolve, reject) => {\n      const contentHeightRef = await isExistWithInTimeout<{current: number}>(lastHeightRef, timeout, 200);\n      if(contentHeightRef) {\n        resolve(lastHeightRef.current);\n      } else {\n        reject(null);\n      }\n    })\n  }, [lastHeightRef, contentRef, timeout]);\n\n  const toggleClose = React.useCallback(() => {\n    setHeightValue(lastHeightRef.current + 'px');\n      setTimeout(() => {\n        setHeightValue('0px');\n        setTimeout(() => {\n          setIsOpen(false); \n        }, duration);\n      });\n  }, [setHeightValue, setHeightValue, setIsOpen]);\n\n  const toggleOpen = React.useCallback(() => {\n    setIsLoading(true);\n    setIsOpen(true);\n    setIsInit(false);\n    onLoadContentHandler()\n      .then((height) => {\n        setIsLoading(false);\n        setTimeout(() => {\n          setIsInit(true);\n          setHeightValue('0px');\n          requestAnimationFrame(() => {\n            setHeightValue(`${height}px`);\n            setTimeout(() => setHeightValue('auto'), duration);\n          })\n        });\n      })\n      \n  }, [setIsOpen, setIsInit, setIsLoading, setHeightValue, onLoadContentHandler, duration]);\n\n  const toggleHandler = React.useCallback<React.MouseEventHandler<Element>>(() => {\n    if(isAnimating) {\n      return;\n    }\n    if(isOpen) {\n      toggleClose();\n    } else {\n      toggleOpen();\n    }\n  }, [isOpen, isAnimating, toggleClose, toggleOpen]);\n  \n  // React.useEffect(() => {\n  //   if(isOpen) {\n  //     if(lastHeightRef.current) {\n  //       onLoadContent((contentRef.current) as Element, 'img')\n  //         .then(() => {\n  //           setIsInit(false);\n  //           setTimeout(() => {\n  //             setIsInit(true);\n  //             setHeightValue('0px');\n  //             setTimeout(() => setHeightValue(lastHeightRef.current + 'px'), 20);\n  //           }, 0)\n  //         })\n  //     };\n  //   }\n  // }, [isOpen, timeout, setIsLoading, setIsError, setHeightValue, setIsInit, lastHeightRef, contentRef])\n\n  return (\n    <Wrapper className=\"toggle-article\">\n      <Title isOpen={heightValue !== '0px' && isOpen} onClick={toggleHandler} duration={duration} className=\"toggle__title\">{title}</Title>\n      {(loading && isOpen && isLoading) && loading}\n      <Content \n        height={heightValue}\n        isInit={isInit} \n        ref={contentRef} \n        duration={duration}\n        will-change=\"true\"\n        className={`toggle__content ${isOpen ? '' : 'hidden'}`}\n      >\n        {isOpen && children}\n      </Content>\n    </Wrapper>\n  )\n};\n\nexport default React.memo(Toggle);\n\ninterface StyledProps {\n  height: string;\n  isInit: boolean;\n  isOpen: boolean;\n  duration: number;\n}\n\nexport const Title = styled.div<Pick<StyledProps, 'isOpen' | 'duration'>>`\n  display: flex;\n  align-items: center;\n  padding-bottom: 8px;\n  cursor: pointer;\n  &::before {\n    margin-right: 8px;\n    transition: transform ${({duration}) => duration}ms;\n    ${({isOpen}) => !!isOpen && ({\n      transform: 'rotate(90deg)'\n    })}\n    cursor: pointer;\n    font-size: inherit;\n    line-height: inherit;\n    content: '▶'\n  }\n`;\nexport const Content = styled.div<Omit<StyledProps, 'isOpen'>>`\n  position: relative;\n  padding-left: 8px;\n  overflow: hidden;\n  left: 0; \n  top: 0;\n  ${({isInit, height, duration}) => `\n    ${isInit ? `\n      transition: height ${duration}ms;\n      height: ${height};\n    ` : `\n      position: absolute;\n      z-index: -9999;\n      height: auto;\n      visibility: hidden;\n      opacity: 0;\n    `}\n  `};\n`\n\nexport const Wrapper = styled.article`\n  position: relative;\n`","/Users/dohyeon.kim/Desktop/workspace/web-api/src/components/AsyncToggle.tsx",["134","135","136","137"],"import React from 'react';\nimport ResizeObservable from '@src/lib/ResizeObservable';\nimport {ToggleProps, Wrapper, Title, Content} from './Toggle';\nimport { isExistWithInTimeout } from '@src/utils';\n\nconst ob = new ResizeObservable();\n\ntype NodeHTML = React.ReactNode | string;\ntype GetHTMLOfPromise = (open: boolean) => Promise<NodeHTML>;\ntype GetChildrenOfFunc = (open: boolean) => React.ReactNode;\n\ninterface Props extends ToggleProps  {\n  children: GetChildrenOfFunc | GetHTMLOfPromise;\n}\n\nconst AsyncToggle: React.FC<Props> = ({title, children, loading, duration = 300, timeout = 3000}) => {\n  const contentRef = React.useRef<HTMLDivElement>(null);\n  const lastHeightRef = React.useRef<number>(0);\n  const [heightValue, setHeightValue] = React.useState<string>('0px');\n  const [isInit, setIsInit] = React.useState<boolean>(false); // false 일 경우 visibility 속성을 통해 실제 사이즈를 구하는 상태\n  const [isOpen, setIsOpen] = React.useState<boolean>(false);\n  const [isAnimating, setIsAnimating] = React.useState<boolean>(false);\n  const [isLoading, setIsLoading] = React.useState<boolean>(false);\n  const [node, setNode] = React.useState< | React.ReactNode>(null);\n  const [html, setHTML] = React.useState<string | null>(null);\n\n  const resizeHandler = React.useCallback(({height}: DOMRect) => {\n    if(isOpen && height && !isAnimating) {\n      lastHeightRef.current = height;\n    }\n  }, [isOpen, isAnimating, lastHeightRef]);\n\n  React.useLayoutEffect(() => {\n    ob.register(contentRef.current as HTMLDivElement, resizeHandler);\n    return () => ob.disconnect();\n  }, [resizeHandler, contentRef]);\n\n  React.useLayoutEffect(() => {\n    const transitionStartHandler = () => setIsAnimating(true);\n    const transitionEndHandler = () => setIsAnimating(false);\n    // 내용이 열리고 동적으로 컨텐츠가 추가 됬을 때 사이즈 감지를 위해 스타일 속성 중 height 를 auto로 변환시킴.\n\n    const {current} = contentRef;\n    contentRef.current?.addEventListener?.('transitionstart', transitionStartHandler);\n    contentRef.current?.addEventListener?.('transitionend', transitionEndHandler);\n    contentRef.current?.addEventListener?.('transitioncancel', transitionEndHandler);\n\n    return () => {\n      current?.removeEventListener?.('transitionstart', transitionStartHandler);\n      current?.removeEventListener?.('transitionend', transitionEndHandler);\n      current?.removeEventListener?.('transitioncancel', transitionEndHandler);\n    }\n  }, [contentRef, setHeightValue, setIsAnimating]);\n\n  const setContents = React.useCallback((isOpen) => {\n    return new Promise((resolve) => {\n      const setHTMLNode = (value: React.ReactNode) => {\n        if(value instanceof String) {\n          setHTML(value as string);\n        } else {\n          setNode(value as React.ReactNode);\n        }\n        resolve(null);\n      }\n      const content = children(isOpen);\n      if(content instanceof Promise) {\n        return content.then(setHTMLNode);\n      } \n      setHTMLNode(content);\n    })\n    \n  }, [setHTML, setNode, contentRef, children]);\n\n  const onLoadContentHandler = React.useCallback<() => Promise<number>>(() => {\n    return new Promise(async (resolve, reject) => {\n      const contentHeightRef = await isExistWithInTimeout<{current: number}>(lastHeightRef, timeout, 200);\n      if(contentHeightRef) {\n        resolve(lastHeightRef.current);\n      } else {\n        reject(null);\n      }\n    })\n  }, [lastHeightRef, contentRef, timeout]);\n\n  const toggleClose = React.useCallback(() => {\n    setHeightValue(lastHeightRef.current + 'px');\n      setTimeout(() => {\n        setHeightValue('0px');\n        setTimeout(() => {\n          setIsOpen(false); \n          setContents(false);\n        }, duration);\n      });\n  }, [setContents, setHeightValue, setHeightValue, setIsOpen]);\n\n  const toggleOpen = React.useCallback(() => {\n    setIsLoading(true);\n    setIsOpen(true);\n    setIsInit(false);\n    setContents(true)\n      .then(() => {\n        onLoadContentHandler()\n          .then((height) => {\n            setIsLoading(false);\n            setTimeout(() => {\n              setIsInit(true);\n              setHeightValue('0px');\n              requestAnimationFrame(() => {\n                setHeightValue(`${height}px`);\n                setTimeout(() => setHeightValue('auto'), duration);\n              })\n            });\n          })\n      });\n  }, [setIsOpen, setIsInit, setIsLoading, setHeightValue, onLoadContentHandler, duration, children]);\n\n  const toggleHandler = React.useCallback<React.MouseEventHandler<Element>>(() => {\n    if(isAnimating) {\n      return;\n    }\n    if(isOpen) {\n      toggleClose();\n    } else {\n      toggleOpen();\n    }\n  }, [isOpen, isAnimating, toggleClose, toggleOpen]);\n\n  return (\n    <Wrapper className=\"toggle-article\">\n      <Title isOpen={isOpen} onClick={toggleHandler} duration={duration} className=\"toggle__title\">{title}</Title>\n      {(isLoading && isOpen && loading) && loading}\n      <Content \n        height={heightValue}\n        isInit={isInit} \n        ref={contentRef} \n        duration={duration}\n        will-change=\"true\"\n        className={`toggle__content ${isOpen ? '' : 'hidden'}`}\n      >\n        {(html || node) &&  (\n          html ? <div dangerouslySetInnerHTML={{__html: html}} /> : node\n        )}\n      </Content>\n    </Wrapper>\n  )\n};\n\nAsyncToggle.displayName = 'AsyncToggle';\nexport default React.memo(AsyncToggle);","/Users/dohyeon.kim/Desktop/workspace/web-api/src/components/PerformanceTestButton.tsx",[],"/Users/dohyeon.kim/Desktop/workspace/web-api/src/utils/index.ts",[],"/Users/dohyeon.kim/Desktop/workspace/web-api/src/lib/ResizeObservable.ts",[],{"ruleId":"138","severity":1,"message":"139","line":24,"column":9,"nodeType":"140","endLine":30,"endColumn":4},{"ruleId":"138","severity":1,"message":"141","line":49,"column":6,"nodeType":"142","endLine":49,"endColumn":16,"suggestions":"143"},{"ruleId":"144","severity":1,"message":"145","line":28,"column":13,"nodeType":"146","endLine":28,"endColumn":41},{"ruleId":"147","severity":1,"message":"148","line":102,"column":78,"nodeType":"149","messageId":"150","endLine":102,"endColumn":80},{"ruleId":"147","severity":1,"message":"148","line":102,"column":78,"nodeType":"149","messageId":"150","endLine":102,"endColumn":80},{"ruleId":"138","severity":1,"message":"151","line":75,"column":6,"nodeType":"142","endLine":75,"endColumn":31,"suggestions":"152"},{"ruleId":"138","severity":1,"message":"153","line":53,"column":18,"nodeType":"154","endLine":53,"endColumn":25},{"ruleId":"138","severity":1,"message":"155","line":66,"column":6,"nodeType":"142","endLine":66,"endColumn":42,"suggestions":"156"},{"ruleId":"138","severity":1,"message":"157","line":76,"column":6,"nodeType":"142","endLine":76,"endColumn":49,"suggestions":"158"},{"ruleId":"138","severity":1,"message":"155","line":72,"column":6,"nodeType":"142","endLine":72,"endColumn":46,"suggestions":"159"},{"ruleId":"138","severity":1,"message":"155","line":83,"column":6,"nodeType":"142","endLine":83,"endColumn":42,"suggestions":"160"},{"ruleId":"138","severity":1,"message":"157","line":94,"column":6,"nodeType":"142","endLine":94,"endColumn":62,"suggestions":"161"},{"ruleId":"138","severity":1,"message":"162","line":115,"column":6,"nodeType":"142","endLine":115,"endColumn":100,"suggestions":"163"},"react-hooks/exhaustive-deps","The 'constraints' object makes the dependencies of useCallback Hook (at line 39) change on every render. To fix this, wrap the initialization of 'constraints' in its own useMemo() Hook.","VariableDeclarator","React Hook React.useCallback has a missing dependency: 'constraints'. Either include it or remove the dependency array.","ArrayExpression",["164"],"jsx-a11y/img-redundant-alt","Redundant alt attribute. Screen-readers already announce `img` tags as an image. You don’t need to use the words `image`, `photo,` or `picture` (or any specified custom words) in the alt prop.","JSXOpeningElement","array-callback-return","Array.prototype.filter() expects a value to be returned at the end of arrow function.","ArrowFunctionExpression","expectedAtEnd","React Hook React.useEffect has a missing dependency: 'getRoomListFromSocket'. Either include it or remove the dependency array.",["165"],"The ref value 'contentRef.current' will likely have changed by the time this effect cleanup function runs. If this ref points to a node rendered by React, copy 'contentRef.current' to a variable inside the effect, and use that variable in the cleanup function.","Identifier","React Hook React.useCallback has an unnecessary dependency: 'contentRef'. Either exclude it or remove the dependency array.",["166"],"React Hook React.useCallback has a missing dependency: 'duration'. Either include it or remove the dependency array.",["167"],["168"],["169"],["170"],"React Hook React.useCallback has a missing dependency: 'setContents'. Either include it or remove the dependency array.",["171"],{"desc":"172","fix":"173"},{"desc":"174","fix":"175"},{"desc":"176","fix":"177"},{"desc":"178","fix":"179"},{"desc":"180","fix":"181"},{"desc":"176","fix":"182"},{"desc":"183","fix":"184"},{"desc":"185","fix":"186"},"Update the dependencies array to be: [constraints]",{"range":"187","text":"188"},"Update the dependencies array to be: [setRoomList, setLoading, getRoomListFromSocket]",{"range":"189","text":"190"},"Update the dependencies array to be: [lastHeightRef, timeout]",{"range":"191","text":"192"},"Update the dependencies array to be: [duration]",{"range":"193","text":"194"},"Update the dependencies array to be: [setHTML, setNode, children]",{"range":"195","text":"196"},{"range":"197","text":"192"},"Update the dependencies array to be: [duration, setContents]",{"range":"198","text":"199"},"Update the dependencies array to be: [setContents, onLoadContentHandler, duration]",{"range":"200","text":"201"},[1345,1355],"[constraints]",[2220,2245],"[setRoomList, setLoading, getRoomListFromSocket]",[2443,2479],"[lastHeightRef, timeout]",[2730,2773],"[duration]",[2927,2967],"[setHTML, setNode, children]",[3336,3372],[3653,3709],"[duration, setContents]",[4282,4376],"[setContents, onLoadContentHandler, duration]"]